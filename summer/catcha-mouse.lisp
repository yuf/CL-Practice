(defparameter *world* nil)
(defparameter *value-list* nil)
(defparameter *traps* nil)
(defparameter *holes* nil)
(defparameter *mouse-position* nil)

(defun map-int (fn a b)
  (loop for i from a to b
     collect (funcall fn i)))

(defun make-world ()
  (flet ((world-filter (x)
	   (multiple-value-bind (c r) (floor x 10)
	     (or (= r 0) (and (evenp c) (= r 9))))))
    (remove-if #'world-filter (map-int #'identity 10 80))))

(defun get-adjacent (n)
  (flet ((in-world? (x)
	   (member x *world*)))
    (let ((r (floor n 10)))
      (if (evenp r)
	  (remove-if-not #'in-world? (list (1- n) (1+ n) (- n 9) (+ n 10) (- n 10) (+ n 11)))
	  (remove-if-not #'in-world? (list (1- n) (1+ n) (- n 10) (+ n 9) (- n 11) (+ n 10)))))))

(defun attach-value (n value &key override)
  (flet ((add-and-filter (filter-fn)
	   (setq *value-list* (cons (cons n value) (remove-if filter-fn *value-list*)))))
    (let ((old-value (assoc n *value-list*)))
      (cond ((null old-value) (add-and-filter #'null))
	    (override (add-and-filter (lambda (x) (equal (car x) (car old-value)))))
	    (t *value-list*)))))

(defun get-value (n)
  (cdr (assoc n *value-list*)))

(defun spread-value (n fn)
  (labels ((spread (queue fn visited)
	     (if (null queue)
		 *value-list*
		 (let* ((node (caar queue))
			(dist (cadar queue))
			(unvisited-adj (remove-if (lambda (x) (member x visited)) (valid-moves node))))
		   (dolist (x unvisited-adj)
		     (push x visited))
		   (attach-value node (+ (get-value node) (funcall fn dist)) :override t)
		   (spread (append (cdr queue) (mapcar (lambda (x) (list x (1+ dist))) unvisited-adj)) fn visited)))))
    (spread (list (list n 0)) fn (list n))))

(defun walking-area (n)
  (labels ((bfs (queue visited)
	     (if (null queue)
		 visited
		 (let* ((node (caar queue))
			(dist (cdar queue))
			(unvisited-adj (remove-if (lambda (x) (or (member x visited :key #'car) (member x *traps*))) (get-adjacent node))))
		   (dolist (x unvisited-adj)
		     (push (cons x (1+ dist)) visited))
		   (bfs (append (cdr queue) (mapcar (lambda (x) (cons x (1+ dist))) unvisited-adj)) visited)))))
    (bfs (list (cons n 0)) (list (cons n 0)))))

(defun player-win? ()
  (notany (lambda (x) (member (car x) *holes*)) (walking-area *mouse-position*)))

(defun player-lose? ()
  (intersection (get-adjacent *mouse-position*) *holes*))

(defun valid-moves (n)
  (remove-if (lambda (x) (member x *traps*)) (get-adjacent n)))

(defun mouse-move ()
  (setq *mouse-position* (most-valuable-move *mouse-position*)))

(defun nearest-trap-quickest-move (position)
  (flet ((find-position-min (all-values filter-fn)
	   (caar (sort (remove-if-not filter-fn all-values) #'< :key #'cdr))))
    (let ((nearest-trap (find-position-min (walking-area position) (lambda (x) (member (car x) *holes*)))))
      (find-position-min (walking-area nearest-trap) (lambda (x) (member (car x) (valid-moves position)))))))

(defun most-valuable-move(position)
  (caar (sort (remove-if-not (lambda (x) (member (car x) (valid-moves position))) *value-list*) #'> :key #'cdr)))  

(defun add-trap (n)
  (flet ((valid-trap-place? (x)
	   (and (member x *world*) (not (member x *traps*)) (not (= x *mouse-position*)))))
    (if (valid-trap-place? n)
	(push n *traps*)
	nil)))

(defun start ()
  (init-game)
  (format t "Mouse is now: ~A~%" *mouse-position*)
  (format t "Traps are: ~S~%" *traps*)
  (format t "Holes are: ~S~%" *holes*)
  (game-loop))
  
(defun game-loop ()
  (labels ((player-add-trap ()
	     (format t "Where do you want to put a trap: ")
	     (let ((result (add-trap (read))))
	       (if result
		   (format t "Now you have traps: ~S~%" *traps*)
		   (progn (format t "Invalid place!~%")
			  (player-add-trap))))))
    (player-add-trap))
  (when (player-win?)
    (format t "You win! Cong!")
    (return-from game-loop))
  (calculate-value)
  (mouse-move)
  (format t "Mouse moved to ~A~%" *mouse-position*)
  (when (player-lose?)
    (format t "You lose!")
    (return-from game-loop))
  (game-loop))

(defun init-game ()
  (setq *print-pretty* nil)
  (setq *world* (make-world))
  (setq *value-list* (mapcar (lambda (x) (cons x 0)) *world*))
  (setq *traps* '(18))
  (setq *mouse-position* 11)
  (setq *holes* '(19 79)))

(defun calculate-value()
  (flet ((spread-fn-1 (x) (- (* x x)))
	 (spread-fn-2 (x)
	   (if (> 3 x)
	       0
	       (- (- x 4) (- x 4)))))
    (dolist (x *holes*)
      (spread-value x #'spread-fn-1))
    (dolist (x *traps*)
      (spread-value x #'spread-fn-2))))