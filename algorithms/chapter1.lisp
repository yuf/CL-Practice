B1;2600;0c(defun multiply (x y)
  (if (= 0 y)
      0
      (let ((z (multiply x (truncate (/ y 2)))))
	(if (evenp y)
	    (* z 2)
	    (+ x (* z 2))))))

(defun divide (x y)
  (if (= x 0)
      (values 0 0)
      (multiple-value-bind (q r) (divide (truncate (/ x 2)) y)
	(setq q (* q 2))
	(setq r (* r 2))
	(when (oddp x)
	  (incf r))
	(when (>= r y)
	  (decf r y)
	  (incf q))
	(values q r))))

(defun power (x y)
  (cond ((= y 0) 1)
	((= y 1) x)
	((evenp y) (power (* x x) (/ y 2)))
	((oddp y) (* (power (* x x) (truncate (/ y 2))) x))
	(t nil)))

(defun modexp (x y N)
  (if (= y 0)
      1
      (let ((z (modexp x (truncate (/ y 2)) N)))
	(flet ((modN (x) (mod x N)))
	(if (evenp y)
	    (modN (* z z))
	    (modN (* z z x)))))))

(defun Euclid (a b)
  (if (= b 0)
      a
      (Euclid b (mod a b))))

(defun extended-Euclid (a b)
  (if (= b 0)
      (values a 1 0)
      (multiple-value-bind (d new-x new-y) (extended-Euclid b (mod a b))
	  (values d new-y (- new-x (* new-y (truncate (/ a b))))))))

(defun primality (N)
  (let ((a (random N)))
    (if (= (modexp a (- N 1) N) 1)
	t
	nil)))

(defun map-int (fn n)
  (let ((result nil))
    (dotimes (i n (reverse result))
		(push (funcall fn (+ i 1)) result))))
    

(defun primality2_1 (N)
  (every (lambda (x) (= x 1))
	 (map-int (lambda (x)
		    (let ((a (1+ (random (1- N)))))
		      (modexp a (1- N) N)))
		  100)))
(defun primality2_2 (N)
  (let ((result t))
    (dotimes (i 100 result)
      (setq result 
	    (and result
		 (= (modexp (1+ (random (1- N))) (1- N) N)
		    1))))))
(defun primality2_3 (N)
  (flet ((randomN (x) (1+ (random (1- x)))))
    (dotimes (i 100)
      (if (not (= (modexp (randomN N) (1- N) N) 1))
	(return-from primality2_3 nil))))
  (return-from primality2_3 t))

(defun filter_1 (fn lst)
  (let ((result nil))
    (dolist (x lst (reverse result))
      (when (funcall fn x)
	(push x result)))))
(defun filter_2 (fn lst)
  (if (null lst)
      nil
      (let ((x (car lst)))
	(if (funcall fn x)
	    (cons x (filter_2 fn (cdr lst)))
	    (filter_2 fn (cdr lst))))))
(defun random-prime (N)
  (let* ((lst (filter_1 #'primality2_3 (cdr (map-int #'identity N))))
	 (len (length lst)))
    (nth (random len) lst)))

(defun get-relative-prime (N)
  (dotimes (i (1- N))
    (multiple-value-bind (d a) (extended-Euclid (+ i 2) N)
      (when (= d 1)
	(return-from get-relative-prime (values (+ i 2) (mod a N)))))))
(let* ((p (random-prime 100))
       (q (random-prime 100))
       (N (* p q)))
  (multiple-value-bind (e d) (get-relative-prime (* (1- p) (1- q)))
    (defun encode (x)
      (power x e))
    (defun decode (x)
      (modexp x d N))))

(defun hello ()
  (print "hello world!"))